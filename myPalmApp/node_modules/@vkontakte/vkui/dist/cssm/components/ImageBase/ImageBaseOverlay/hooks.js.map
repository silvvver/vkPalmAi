{"version":3,"sources":["../../../../../src/components/ImageBase/ImageBaseOverlay/hooks.ts"],"sourcesContent":["import * as React from 'react';\nimport { hasMouse as hasPointerLib } from '@vkontakte/vkjs';\nimport { useAdaptivity } from '../../../hooks/useAdaptivity';\nimport { useFocusWithin } from '../../../hooks/useFocusWithin';\nimport { useIsClient } from '../../../hooks/useIsClient';\nimport { useIsomorphicLayoutEffect } from '../../../lib/useIsomorphicLayoutEffect';\n\nexport function useNonInteractiveOverlayProps(rootRef: React.RefObject<HTMLElement | null>) {\n  const focusWithin = useFocusWithin(rootRef);\n  const [nonInteractiveFocusShown, setNonInteractiveFocusShown] = React.useState(false);\n\n  function onClick(event: React.MouseEvent) {\n    if (event.detail > 0) {\n      // Если мы попали на вложенный в оверлей элемент через focus,\n      // то при клике мышкой мы должны начать реагировать на hover-состояние,\n      // даже если фокус всё ещё остался на вложенном элементе (был по нему клик)\n      setNonInteractiveFocusShown(false);\n    }\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    setNonInteractiveFocusShown(focusWithin);\n  }, [focusWithin]);\n\n  return {\n    shown: nonInteractiveFocusShown && focusWithin,\n    onClick,\n  };\n}\n\n/*\n * Определям значение по умолчанию для свойства visibility.\n *\n * Задача состоит в том, чтобы правильно рендерить Overlay.\n * Для устройств с мышкой, мы можем показывать его по наведению,\n * а для остальных устройств он должен быть виден всегда.\n *\n * Задача в том, чтобы избежать проблем при гидратации,\n * и отложить использование значения `always`, пока мы точно не уверены, что у пользоватея действительно нет мышки.\n * Иначе Overlay при первом рендере может показаться, а потом исчезнуть.\n *\n * Основано на хуке `useAdaptivityHasPointer`, но если при первом рендере мы точно не знаем значения hasPointer, то возвращаем `on-hover`.\n * */\nexport function useCalculatedDefaultVisibility() {\n  const { hasPointer: hasPointerContext } = useAdaptivity();\n\n  const needTwoPassRendering = hasPointerContext === undefined;\n  const isClient = useIsClient(!needTwoPassRendering);\n\n  if (!isClient && hasPointerContext === undefined) {\n    return 'on-hover';\n  }\n\n  const hasPointer = hasPointerContext ?? hasPointerLib;\n\n  return hasPointer ? 'on-hover' : 'always';\n}\n"],"names":["React","hasMouse","hasPointerLib","useAdaptivity","useFocusWithin","useIsClient","useIsomorphicLayoutEffect","useNonInteractiveOverlayProps","rootRef","focusWithin","nonInteractiveFocusShown","setNonInteractiveFocusShown","useState","onClick","event","detail","shown","useCalculatedDefaultVisibility","hasPointer","hasPointerContext","needTwoPassRendering","undefined","isClient"],"mappings":"AAAA,YAAYA,WAAW,QAAQ;AAC/B,SAASC,YAAYC,aAAa,QAAQ,kBAAkB;AAC5D,SAASC,aAAa,QAAQ,kCAA+B;AAC7D,SAASC,cAAc,QAAQ,mCAAgC;AAC/D,SAASC,WAAW,QAAQ,gCAA6B;AACzD,SAASC,yBAAyB,QAAQ,4CAAyC;AAEnF,OAAO,SAASC,8BAA8BC,OAA4C;IACxF,MAAMC,cAAcL,eAAeI;IACnC,MAAM,CAACE,0BAA0BC,4BAA4B,GAAGX,MAAMY,QAAQ,CAAC;IAE/E,SAASC,QAAQC,KAAuB;QACtC,IAAIA,MAAMC,MAAM,GAAG,GAAG;YACpB,6DAA6D;YAC7D,uEAAuE;YACvE,2EAA2E;YAC3EJ,4BAA4B;QAC9B;IACF;IAEAL,0BAA0B;QACxBK,4BAA4BF;IAC9B,GAAG;QAACA;KAAY;IAEhB,OAAO;QACLO,OAAON,4BAA4BD;QACnCI;IACF;AACF;AAEA;;;;;;;;;;;;GAYG,GACH,OAAO,SAASI;IACd,MAAM,EAAEC,YAAYC,iBAAiB,EAAE,GAAGhB;IAE1C,MAAMiB,uBAAuBD,sBAAsBE;IACnD,MAAMC,WAAWjB,YAAY,CAACe;IAE9B,IAAI,CAACE,YAAYH,sBAAsBE,WAAW;QAChD,OAAO;IACT;IAEA,MAAMH,aAAaC,qBAAqBjB;IAExC,OAAOgB,aAAa,aAAa;AACnC"}