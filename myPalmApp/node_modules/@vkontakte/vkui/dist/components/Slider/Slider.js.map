{"version":3,"sources":["../../../src/components/Slider/Slider.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { clamp } from '../../helpers/math';\nimport { mergeStyle } from '../../helpers/mergeStyle';\nimport { useAdaptivity } from '../../hooks/useAdaptivity';\nimport { useConfigDirection } from '../../hooks/useConfigDirection';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport type { CSSCustomProperties, HTMLAttributesWithRootRef } from '../../types';\nimport { type CustomTouchEvent, type CustomTouchEventHandler, Touch } from '../Touch/Touch';\nimport { SliderThumb } from './SliderThumb/SliderThumb';\nimport {\n  extractSliderAriaAttributesFromRestProps,\n  getDraggingTypeByTargetDataset,\n  isMultipleValues,\n  offsetToValue,\n  snapDirection,\n  toPercent,\n  updateInternalStateValue,\n  updateInternalStateValueByNativeChange,\n} from './helpers';\nimport type { InternalDraggingType, InternalGestureRef, InternalValueState } from './types';\nimport styles from './Slider.module.css';\n\nconst sizeYClassNames = {\n  none: styles.sizeYNone,\n  compact: styles.sizeYCompact,\n};\n\nconst sizeClassNames = {\n  l: styles.sizeL,\n  m: styles.sizeM,\n  s: styles.sizeS,\n};\n\nexport interface SliderBaseProps\n  extends Omit<HTMLAttributesWithRootRef<HTMLDivElement>, 'value' | 'defaultValue' | 'onChange'> {\n  /**\n   * Минимальное значение слайдера.\n   */\n  min?: number;\n  /**\n   * Максимальное значение слайдера.\n   */\n  max?: number;\n  /**\n   * Шаг изменения значения слайдера.\n   */\n  step?: number;\n  /**\n   * Блокировка взаимодействия с компонентом.\n   */\n  disabled?: boolean;\n  /**\n   * Тоже самое, что и `aria-label`, но на вход можно получать индекс текущего ползунка и в зависимости от этого выдавать разный текст.\n   *\n   * > Перебивает `aria-label`.\n   */\n  getAriaLabel?: (index: number) => string;\n  /**\n   * В отличие от `aria-valuetext`, позволяет более гибко форматировать текст в зависимости от значения ползунка.\n   *\n   * Полезно при использовании компонента как неконтролируемого.\n   *\n   * > Перебивает `aria-valuetext`.\n   */\n  getAriaValueText?: (value: number, index: number) => string;\n  /**\n   * Включает отображение всплывающей подсказки при взаимодействии с ползунком.\n   */\n  withTooltip?: boolean;\n  /**\n   * Размер ползунка.\n   */\n  size?: 's' | 'm' | 'l';\n  /**\n   * Передает атрибут `data-testid` для первого ползунка.\n   */\n  startThumbTestId?: string;\n  /**\n   * Передает атрибут `data-testid` для второго ползунка когда `multiple=true`.\n   */\n  endThumbTestId?: string;\n}\n\nexport interface SliderProps extends SliderBaseProps {\n  /**\n   * Флаг множественного выбора (должен быть false или не указан).\n   */\n  multiple?: false;\n  /**\n   * Текущее значение слайдера.\n   */\n  value?: number;\n  /**\n   * Значение слайдера по умолчанию.\n   */\n  defaultValue?: number;\n  /**\n   * Обработчик изменения значения слайдера.\n   */\n  onChange?: (value: number, event: CustomTouchEvent | React.ChangeEvent) => void;\n}\n\nexport interface SliderMultipleProps extends SliderBaseProps {\n  /**\n   * Флаг множественного выбора (должен быть true).\n   */\n  multiple: true;\n  /**\n   * Текущие значения слайдера в виде массива [начальное, конечное].\n   */\n  value?: [number, number];\n  /**\n   * Значения слайдера по умолчанию в виде массива [начальное, конечное].\n   */\n  defaultValue?: [number, number];\n  /**\n   * Обработчик изменения значений слайдера.\n   */\n  onChange?: (value: [number, number], event: CustomTouchEvent | React.ChangeEvent) => void;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Slider\n */\nexport const Slider = ({\n  step = 1,\n  min = 0,\n  max = 100,\n  value: valueProp,\n  multiple: multipleProp,\n  defaultValue = multipleProp ? [min, max] : min,\n  disabled,\n  className,\n  getRootRef,\n  getAriaLabel,\n  getAriaValueText,\n  startThumbTestId,\n  endThumbTestId,\n  onChange,\n  withTooltip,\n  size = 'l',\n  style: styleProp,\n  ...restProps\n}: SliderProps | SliderMultipleProps): React.ReactNode => {\n  const { sizeY = 'none' } = useAdaptivity();\n  const direction = useConfigDirection();\n  const isRtl = direction === 'rtl';\n\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = React.useState(defaultValue);\n\n  const value = React.useMemo<InternalValueState>(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n    return Array.isArray(resolvedValue)\n      ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)]\n      : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n  const startValueInPercent = toPercent(startValue, min, max);\n  const endReversedValueInPercent = multiple ? toPercent(endValue, min, max) : 0;\n  const [activeThumb, setActiveThumb] = React.useState<InternalDraggingType | null>(null);\n\n  const gesture = React.useRef<InternalGestureRef>({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0,\n  }).current;\n  const thumbsContainerRef = useExternRef(getRootRef);\n  const thumbStartInputRef = React.useRef<HTMLInputElement>(null);\n  const thumbEndInputRef = React.useRef<HTMLInputElement>(null);\n\n  const { ariaLabel, ariaValueText, ariaLabelledBy, ...restPropsWithoutAriaAttributes } =\n    extractSliderAriaAttributesFromRestProps(restProps);\n\n  const changeValue = (\n    nextValue: InternalValueState,\n    event: CustomTouchEvent | React.ChangeEvent,\n  ) => {\n    if (disabled || (value[0] === nextValue[0] && value[1] === nextValue[1])) {\n      return;\n    }\n\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n\n  const handlePointerStart: CustomTouchEventHandler = (event: CustomTouchEvent) => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n\n    const { left: nextContainerX, width: nextContainerWidth } =\n      thumbsContainerRef.current.getBoundingClientRect();\n\n    // @ts-expect-error: TS2345 в VKUITouchEvent плохо описаны типы. `target` это просто `EventTarget`.\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n\n    let nextStartX = event.startX - nextContainerX;\n    if (isRtl) {\n      nextStartX = nextContainerWidth - nextStartX;\n    }\n    const nextValue = offsetToValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = snapDirection(value, nextValue, foundDraggingType);\n\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n\n    const updatedInternalStateValue = updateInternalStateValue(\n      value,\n      nextValue,\n      min,\n      max,\n      nextDragging,\n    );\n\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (\n      thumbStartInputRef.current &&\n      (foundDraggingType === 'start' ||\n        (nextStartValue !== startValue && nextEndValue === endValue))\n    ) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (\n      thumbEndInputRef.current &&\n      (foundDraggingType === 'end' || (nextEndValue !== endValue && nextStartValue === startValue))\n    ) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n\n    changeValue(updatedInternalStateValue, event);\n\n    event.originalEvent.stopPropagation();\n    setActiveThumb(gesture.dragging);\n  };\n\n  const handlePointerMove: CustomTouchEventHandler = (event: CustomTouchEvent) => {\n    const { startX, containerWidth, dragging } = gesture;\n\n    const { shiftX = 0 } = event;\n    const nextStartX = startX + (isRtl ? -shiftX : shiftX);\n    const nextValue = offsetToValue(nextStartX, containerWidth, min, max, step);\n\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const handlePointerEnd: CustomTouchEventHandler = (event) => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n    setActiveThumb(null);\n  };\n\n  const handleChangeByNativeInput = (event: React.ChangeEvent<HTMLInputElement>) => {\n    changeValue(\n      updateInternalStateValueByNativeChange(\n        value,\n        Number(event.target.value),\n        getDraggingTypeByTargetDataset(event.target),\n      ),\n      event,\n    );\n  };\n\n  const style: CSSCustomProperties = {\n    '--vkui_internal--Slider_start_value': String(startValueInPercent),\n    '--vkui_internal--Slider_end_value': String(endReversedValueInPercent),\n  };\n\n  return (\n    <Touch\n      data-value={multiple ? `${startValue},${endValue}` : startValue}\n      {...restPropsWithoutAriaAttributes}\n      className={classNames(\n        styles.host,\n        disabled && styles.disabled,\n        sizeY !== 'regular' && sizeYClassNames[sizeY],\n        sizeClassNames[size],\n        multiple && styles.multiple,\n        isRtl && styles.rtl,\n        className,\n      )}\n      style={mergeStyle(styleProp, style)}\n      getRootRef={getRootRef}\n      onStart={disabled ? undefined : handlePointerStart}\n      onMove={disabled ? undefined : handlePointerMove}\n      onEnd={disabled ? undefined : handlePointerEnd}\n    >\n      <div className={styles.track} />\n      <div className={styles.trackFill} />\n      <div ref={thumbsContainerRef} className={styles.thumbs}>\n        <SliderThumb\n          data-type=\"start\"\n          className={classNames(styles.thumb, styles.thumbStart)}\n          style={{\n            // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.\n            zIndex: multiple && startValueInPercent >= 50 ? 2 : undefined,\n          }}\n          withTooltip={withTooltip}\n          inputProps={{\n            'data-type': 'start',\n            'data-testid': startThumbTestId,\n            'ref': thumbStartInputRef,\n            'step': step,\n            'min': min,\n            'value': startValue,\n            'max': multiple ? endValue : max,\n            'disabled': disabled,\n            'aria-label': getAriaLabel ? getAriaLabel(0) : ariaLabel,\n            'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,\n            'aria-labelledby': ariaLabelledBy,\n            'onChange': handleChangeByNativeInput,\n          }}\n          isActive={activeThumb === 'start'}\n        />\n        {multiple && (\n          <SliderThumb\n            data-type=\"end\"\n            className={classNames(styles.thumb, styles.thumbEnd)}\n            withTooltip={withTooltip}\n            inputProps={{\n              'data-type': 'end',\n              'data-testid': endThumbTestId,\n              'ref': thumbEndInputRef,\n              'step': step,\n              'min': startValue,\n              'value': endValue,\n              'max': max,\n              'disabled': disabled,\n              'aria-label': getAriaLabel ? getAriaLabel(1) : ariaLabel,\n              'aria-valuetext': getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,\n              'aria-labelledby': ariaLabelledBy,\n              'onChange': handleChangeByNativeInput,\n            }}\n            isActive={activeThumb === 'end'}\n          />\n        )}\n      </div>\n    </Touch>\n  );\n};\n"],"names":["React","classNames","clamp","mergeStyle","useAdaptivity","useConfigDirection","useExternRef","Touch","SliderThumb","extractSliderAriaAttributesFromRestProps","getDraggingTypeByTargetDataset","isMultipleValues","offsetToValue","snapDirection","toPercent","updateInternalStateValue","updateInternalStateValueByNativeChange","sizeYClassNames","none","compact","sizeClassNames","l","m","s","Slider","step","min","max","value","valueProp","multiple","multipleProp","defaultValue","disabled","className","getRootRef","getAriaLabel","getAriaValueText","startThumbTestId","endThumbTestId","onChange","withTooltip","size","style","styleProp","restProps","sizeY","direction","isRtl","isControlled","undefined","localValue","setValue","useState","useMemo","resolvedValue","Array","isArray","startValue","endValue","startValueInPercent","endReversedValueInPercent","activeThumb","setActiveThumb","gesture","useRef","dragging","startX","containerWidth","current","thumbsContainerRef","thumbStartInputRef","thumbEndInputRef","ariaLabel","ariaValueText","ariaLabelledBy","restPropsWithoutAriaAttributes","changeValue","nextValue","event","handlePointerStart","left","nextContainerX","width","nextContainerWidth","getBoundingClientRect","foundDraggingType","originalEvent","target","nextStartX","nextDragging","updatedInternalStateValue","nextStartValue","nextEndValue","focus","preventDefault","stopPropagation","handlePointerMove","shiftX","handlePointerEnd","handleChangeByNativeInput","Number","String","data-value","onStart","onMove","onEnd","div","ref","data-type","zIndex","inputProps","isActive"],"mappings":"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"}