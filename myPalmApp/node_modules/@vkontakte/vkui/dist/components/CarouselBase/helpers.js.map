{"version":3,"sources":["../../../src/components/CarouselBase/helpers.ts"],"sourcesContent":["/* eslint-disable jsdoc/require-jsdoc */\nimport { getRequiredValueByKey } from '../../helpers/getValueByKey';\nimport { type AlignType } from '../../types';\nimport { SLIDE_THRESHOLD } from './constants';\nimport {\n  type GallerySlidesState,\n  type LayoutState,\n  type LoopPoint,\n  type SlidesManagerState,\n} from './types';\n\nexport const revertRtlValue = (n: number, isRtl: boolean) => {\n  return isRtl ? -n : n;\n};\n\nexport const isBigger = (a: number, b: number, isRtl: boolean) => (isRtl ? a < b : a > b);\nexport const isBiggerOrEqual = (a: number, b: number, isRtl: boolean) => (isRtl ? a <= b : a >= b);\n\nexport const isLower = (a: number, b: number, isRtl: boolean) => (isRtl ? a > b : a < b);\nexport const isLowerOrEqual = (a: number, b: number, isRtl: boolean) => (isRtl ? a >= b : a <= b);\n\n/*\n * Считает отступ слоя галереи во время драга\n * Используется только для looped=false галереи\n * так как только у нее есть пределы по краям\n */\nexport const validateIndent = (\n  slidesManager: SlidesManagerState,\n  value: number,\n  isRtl: boolean,\n  bounded = true,\n) => {\n  const localMax = slidesManager.max ?? 0;\n  const localMin = slidesManager.min ?? 0;\n\n  const moreThanMax = isBigger(value, localMax, isRtl);\n  if (moreThanMax) {\n    if (bounded) {\n      return localMax;\n    } else {\n      return localMax + Number((value - localMax) / 3);\n    }\n  }\n\n  const lessThanMin = isLower(value, localMin, isRtl);\n  if (lessThanMin) {\n    if (bounded) {\n      return localMin;\n    } else {\n      return localMin + Number((value - localMin) / 3);\n    }\n  }\n\n  return value;\n};\n\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent({\n  targetIndex,\n  slidesManager,\n  isCenter,\n  looped = false,\n  isRtl = false,\n}: {\n  targetIndex: number;\n  slidesManager: SlidesManagerState;\n  isCenter: boolean;\n  looped: boolean;\n  isRtl: boolean;\n}): number {\n  if (!slidesManager.slides.length) {\n    return 0;\n  }\n\n  const targetSlide = slidesManager.slides[targetIndex];\n\n  if (targetSlide) {\n    const { coordX, width } = targetSlide;\n\n    if (isCenter) {\n      return revertRtlValue(slidesManager.containerWidth / 2 - coordX - width / 2, isRtl);\n    }\n    const indent = revertRtlValue(-1 * coordX, isRtl);\n    return looped ? indent : validateIndent(slidesManager, indent, isRtl);\n  }\n\n  return 0;\n}\n\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать.\n */\nexport function getShiftedIndexes(\n  direction: 1 | -1,\n  slides: GallerySlidesState[],\n  availableWidth: number,\n): number[] {\n  let gap = availableWidth;\n  const shiftedSlideIndexes = [];\n  const startIndex = direction === 1 ? 0 : slides.length - 1;\n  const endIndex = direction === 1 ? slides.length - 1 : 0;\n\n  for (\n    let i = startIndex;\n    (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0;\n    i += direction\n  ) {\n    const slideWidth = slides[i].width;\n\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n\n  return shiftedSlideIndexes;\n}\n\nfunction calculateLoopPoints(\n  indexes: number[],\n  edge: 'start' | 'end',\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n  isRtl: boolean,\n): LoopPoint[] {\n  const { contentSize, slides, snaps } = slidesManager;\n  const isStartEdge = edge === 'start';\n  const offset = isStartEdge ? -contentSize : contentSize;\n\n  return indexes.map((index) => {\n    const initial = revertRtlValue(isStartEdge ? 0 : -contentSize, isRtl);\n    const altered = revertRtlValue(isStartEdge ? contentSize : 0, isRtl);\n\n    const snap = revertRtlValue(snaps[index], isRtl);\n    const firstSnap = revertRtlValue(snaps[0], isRtl);\n    const loopPoint = revertRtlValue(\n      isStartEdge\n        ? snap + containerWidth + offset\n        : snap - slides[index].width + offset - firstSnap,\n      isRtl,\n    );\n\n    return {\n      index,\n      target: (currentLocation) =>\n        isBiggerOrEqual(currentLocation, loopPoint, isRtl) ? initial : altered,\n    };\n  });\n}\n\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов.\n */\nexport function getLoopPoints(\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n  isRtl = false,\n): LoopPoint[] {\n  const { slides, snaps } = slidesManager;\n  const firstSnap = revertRtlValue(snaps[0], isRtl);\n  const startShiftedIndexes = getShiftedIndexes(-1, slides, firstSnap);\n  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - firstSnap);\n\n  return [\n    ...calculateLoopPoints(endShiftedIndexes, 'start', slidesManager, containerWidth, isRtl),\n    ...calculateLoopPoints(startShiftedIndexes, 'end', slidesManager, containerWidth, isRtl),\n  ];\n}\n\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex({\n  slides,\n  slideIndex,\n  currentShiftX,\n  currentShiftXDelta,\n  looped = false,\n  max = null,\n  isRtl = false,\n}: {\n  slides: GallerySlidesState[];\n  slideIndex: number;\n  currentShiftX: number;\n  currentShiftXDelta: number;\n  looped: boolean;\n  max?: number | null;\n  isRtl?: boolean;\n}): number {\n  max = max ?? 0;\n  // Инвертируем значения смещения для RTL режима\n  const shift = revertRtlValue(currentShiftX + currentShiftXDelta - max, isRtl);\n\n  // Инвертируем направление для RTL режима\n  const direction = isLower(currentShiftXDelta, 0, isRtl) ? 1 : -1;\n\n  // Находим ближайшую границу слайда к текущему отступу\n  let targetIndex = slides.reduce((val: number, item: GallerySlidesState, index: number) => {\n    // Инвертируем координаты для RTL режима\n    const previousCoordX = slides[val].coordX;\n    const currentCoordX = item.coordX;\n\n    const previousValue = Math.abs(previousCoordX + shift);\n    const currentValue = Math.abs(currentCoordX + shift);\n\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n\n  if (targetIndex === slideIndex) {\n    let targetSlide = slideIndex + direction;\n\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    if (!looped) {\n      return direction < 0 ? Math.max(targetIndex, 0) : Math.min(targetIndex, slides.length - 1);\n    }\n\n    return direction < 0\n      ? (targetSlide + slides.length) % slides.length\n      : targetSlide % slides.length;\n  }\n\n  return targetIndex;\n}\n\ninterface CalcMin extends Partial<LayoutState> {\n  isRtl?: boolean;\n  align: AlignType;\n}\n\nexport const calcMin = ({\n  containerWidth = 0,\n  layerWidth = 0,\n  slides = [],\n  viewportOffsetWidth = 0,\n  isFullyVisible,\n  align,\n  isRtl = false,\n}: CalcMin): number => {\n  if (align !== 'center' && isFullyVisible) {\n    return 0;\n  }\n  const result = getRequiredValueByKey(align, {\n    left: () => containerWidth - layerWidth,\n    right: () => viewportOffsetWidth - layerWidth,\n    center: () => {\n      const { coordX, width } = slides[slides.length - 1];\n      return containerWidth / 2 - coordX - width / 2;\n    },\n  })();\n  return revertRtlValue(result, isRtl);\n};\n\ninterface CalcMax extends Partial<LayoutState> {\n  isRtl?: boolean;\n  isCenterAlign: boolean;\n}\n\nexport const calcMax = ({\n  slides = [],\n  containerWidth = 0,\n  isCenterAlign,\n  isRtl = false,\n}: CalcMax): number => {\n  if (isCenterAlign && slides.length) {\n    const { width, coordX } = slides[0];\n    const result = containerWidth / 2 - coordX - width / 2;\n    return revertRtlValue(result, isRtl);\n  }\n  return 0;\n};\n"],"names":["getRequiredValueByKey","SLIDE_THRESHOLD","revertRtlValue","n","isRtl","isBigger","a","b","isBiggerOrEqual","isLower","isLowerOrEqual","validateIndent","slidesManager","value","bounded","localMax","max","localMin","min","moreThanMax","Number","lessThanMin","calculateIndent","targetIndex","isCenter","looped","slides","length","targetSlide","coordX","width","containerWidth","indent","getShiftedIndexes","direction","availableWidth","gap","shiftedSlideIndexes","startIndex","endIndex","i","slideWidth","push","calculateLoopPoints","indexes","edge","contentSize","snaps","isStartEdge","offset","map","index","initial","altered","snap","firstSnap","loopPoint","target","currentLocation","getLoopPoints","startShiftedIndexes","endShiftedIndexes","getTargetIndex","slideIndex","currentShiftX","currentShiftXDelta","shift","reduce","val","item","previousCoordX","currentCoordX","previousValue","Math","abs","currentValue","calcMin","layerWidth","viewportOffsetWidth","isFullyVisible","align","result","left","right","center","calcMax","isCenterAlign"],"mappings":"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"}