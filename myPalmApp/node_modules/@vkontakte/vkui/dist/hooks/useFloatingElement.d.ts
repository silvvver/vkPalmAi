import * as React from 'react';
import { type Ref } from 'react';
import { type OnPlacementChange, type UseFloatingMiddlewaresBootstrapOptions, type UseFloatingWithInteractionsProps, type UseFloatingWithInteractionsReturn } from '../lib/floating';
import { type ReferenceProps } from '../lib/floating/useFloatingWithInteractions/types';
export type FloatingComponentProps<FloatingElement extends HTMLElement = HTMLElement> = Pick<UseFloatingWithInteractionsReturn, 'shown' | 'willBeHide' | 'floatingProps' | 'middlewareData' | 'onClose' | 'onRestoreFocus' | 'placement'> & {
    floatingRef: React.Ref<FloatingElement>;
    setArrowRef: React.Dispatch<React.SetStateAction<HTMLDivElement | null>>;
};
export type RenderFloatingComponentFn<FloatingElement extends HTMLElement = HTMLElement> = (props: FloatingComponentProps<FloatingElement>) => React.ReactNode | null;
export type RemapReferencePropsFn<ReferenceElement extends HTMLElement = HTMLElement> = (props: ReferenceProps<ReferenceElement> & {
    shown: boolean;
}) => ReferenceProps<ReferenceElement>;
export type UseFloatingElementProps<FloatingElement extends HTMLElement = HTMLElement, ReferenceElement extends HTMLElement = HTMLElement> = Omit<UseFloatingMiddlewaresBootstrapOptions, 'arrowRef'> & Omit<UseFloatingWithInteractionsProps, 'placement'> & {
    onPlacementChange?: OnPlacementChange;
    onReferenceHiddenChange?: (hidden: boolean) => void;
    renderFloatingComponent: RenderFloatingComponentFn<FloatingElement>;
    remapReferenceProps?: RemapReferencePropsFn<ReferenceElement>;
    externalFloatingElementRef?: React.Ref<FloatingElement>;
};
export type UseFloatingResult<ReferenceElement extends HTMLElement = HTMLElement> = {
    anchorRef: Ref<ReferenceElement>;
    anchorProps: ReferenceProps<ReferenceElement>;
    component: React.ReactNode | null;
};
export declare const useFloatingElement: <ReferenceElement extends HTMLElement = HTMLElement, FloatingElement extends HTMLElement = HTMLElement>({ placement, arrow, arrowHeight, arrowPadding, sameWidth, offsetByMainAxis, offsetByCrossAxis, customMiddlewares, hideWhenReferenceHidden, disableFlipMiddleware, trigger, hoverDelay, closeAfterClick, disabled, disableInteractive, disableCloseOnClickOutside, disableCloseOnEscKey, defaultShown, shown: shownProp, onShownChange, onShownChanged, strategy, onReferenceHiddenChange, onPlacementChange, renderFloatingComponent, externalFloatingElementRef, remapReferenceProps, }: UseFloatingElementProps<FloatingElement, ReferenceElement>) => UseFloatingResult<ReferenceElement>;
//# sourceMappingURL=useFloatingElement.d.ts.map